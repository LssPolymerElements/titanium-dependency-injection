declare let TitaniumDependencyResolverMixin: <T extends Polymer.ElementMixinConstructor>(superClass: T) => {
    new (...args: any[]): {
        addEventListener: any;
        ready(): void;
        providers: any;
        unprovidedRequests: any;
        _template: HTMLTemplateElement | null;
        _importPath: string;
        rootPath: string;
        importPath: string;
        root: HTMLElement | ShadowRoot | StampedTemplate | null;
        $: {
            [key: string]: Element;
        };
        _initializeProperties(): void;
        _readyClients(): void;
        connectedCallback(): void;
        _attachDom(dom: StampedTemplate | null): ShadowRoot | null;
        updateStyles(properties?: object | null | undefined): void;
        resolveUrl(url: string, base?: string | undefined): string;
        readonly PROPERTY_EFFECT_TYPES: any;
        _stampTemplate(template: HTMLTemplateElement): StampedTemplate;
        _initializeInstanceProperties(props: object | null): void;
        _setProperty(property: string, value: any): void;
        _setPendingProperty(property: string, value: any, shouldNotify?: boolean | undefined): boolean;
        _invalidateProperties(): void;
        _flushProperties(): void;
        _propertiesChanged(currentProps: object, changedProps: object, oldProps: object): void;
        _initializeProtoProperties(props: object | null): void;
        _addPropertyEffect(property: string, type: string, effect?: object | null | undefined): void;
        _removePropertyEffect(property: string, type: string, effect?: object | null | undefined): void;
        _hasPropertyEffect(property: string, type?: string | undefined): boolean;
        _hasReadOnlyEffect(property: string): boolean;
        _hasNotifyEffect(property: string): boolean;
        _hasReflectEffect(property: string): boolean;
        _hasComputedEffect(property: string): boolean;
        _setPendingPropertyOrPath(path: string | (string | number)[], value: any, shouldNotify?: boolean | undefined, isPathNotification?: boolean | undefined): boolean;
        _setUnmanagedPropertyToNode(node: Node, prop: string, value: any): void;
        _enqueueClient(client: object | null): void;
        _flushClients(): void;
        setProperties(props: object | null, setReadOnly?: boolean | undefined): void;
        _propagatePropertyChanges(changedProps: object | null, oldProps: object | null, hasPaths: boolean): void;
        linkPaths(to: string | (string | number)[], from: string | (string | number)[]): void;
        unlinkPaths(path: string | (string | number)[]): void;
        notifySplices(path: string, splices: any[] | null): void;
        get(path: string | (string | number)[], root?: object | null | undefined): any;
        set(path: string | (string | number)[], value: any, root?: object | null | undefined): void;
        push(path: string | (string | number)[], ...items: any[]): number;
        pop(path: string | (string | number)[]): any;
        splice(path: string | (string | number)[], start: number, deleteCount: number, ...items: any[]): any[] | null;
        shift(path: string | (string | number)[]): any;
        unshift(path: string | (string | number)[], ...items: any[]): number;
        notifyPath(path: string, value?: any): void;
        _createReadOnlyProperty(property: string, protectedSetter?: boolean | undefined): void;
        _createPropertyObserver(property: string, method: string | ((p0: any, p1: any) => any), dynamicFn?: boolean | undefined): void;
        _createMethodObserver(expression: string, dynamicFn?: boolean | object | null | undefined): void;
        _createNotifyingProperty(property: string): void;
        _createReflectedProperty(property: string): void;
        _createComputedProperty(property: string, expression: string, dynamicFn?: boolean | object | null | undefined): void;
        _bindTemplate(template: HTMLTemplateElement, instanceBinding?: boolean | undefined): TemplateInfo;
        _removeBoundDom(dom: StampedTemplate): void;
        _addMethodEventListenerToNode(node: Node, eventName: string, methodName: string, context?: any): Function | null;
        _addEventListenerToNode(node: Node, eventName: string, handler: (p0: Event) => void): void;
        _removeEventListenerFromNode(node: Node, eventName: string, handler: (p0: Event) => void): void;
        _definePropertyAccessor(property: string, readOnly?: boolean | undefined): void;
        _serializeValue(value: any): string | undefined;
        _deserializeValue(value: string | null, type?: any): any;
        _ensureAttribute(attribute: string, value: string): void;
        _hasAccessor(property: string): boolean;
        _isPropertyPending(prop: string): boolean;
        _createPropertyAccessor(property: string, readOnly?: boolean | undefined): void;
        _addPropertyToAttributeMap(property: string): void;
        _getProperty(property: string): any;
        _enableProperties(): void;
        _shouldPropertiesChange(currentProps: object, changedProps: object, oldProps: object): boolean;
        _shouldPropertyChange(property: string, value: any, old: any): boolean;
        attributeChangedCallback(name: string, old: string | null, value: string | null, namespace: string | null): void;
        _attributeToProperty(attribute: string, value: string | null, type?: any): void;
        _propertyToAttribute(property: string, attribute?: string | undefined, value?: any): void;
        _valueToNodeAttribute(node: Element | null, value: any, attribute: string): void;
        disconnectedCallback(): void;
    };
    _parseTemplateContent(template: any, templateInfo: any, nodeInfo: any): any;
    createProperties(props: any): void;
    _finalizeClass(): void;
    _prepareTemplate(): void;
    createObservers(observers: object | null, dynamicFns: object | null): void;
    _processStyleText(cssText: string, baseURI: string): string;
    _finalizeTemplate(is: string): void;
} & T;
